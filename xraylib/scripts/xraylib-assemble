#!/usr/bin/env python

import numpy as np
import os, optparse, itertools
import h5py, fabio

import xraylib
from xraylib import f2w, files, utils, fit

class Assembler(utils.Script):
    def __init__(self, **kwargs):
        super(Assembler, self).__init__()
        self.description = """
        """
        self.peak = {}
        self.peak.update(kwargs)

    def parser_setup(self):
        super(Assembler, self).parser_setup()

        input_group = optparse.OptionGroup(self.parser, "Input options")
        input_group.add_option("--position", dest="peak_position",
                          help="Peak channel position")
        input_group.add_option("--fwhm", dest="peak_fwhm",
                          help="Peak FWHM full width at half maximum")
        input_group.add_option("--shape", dest="peak_shape",
                          help="Peak shape. [gaussian|delta]", default='gaussian')
        input_group.add_option("--peak-file", dest="peak_file",
                          help="Exported peak from DAWN.", metavar="FILE")
        input_group.add_option("--input-set", dest="input_set",
                          help='Override data set [default %s].' % (xraylib.DIFFRACTOGRAM_DATA_SET,),
                          metavar="STRING", default=xraylib.DIFFRACTOGRAM_DATA_SET)
        self.parser.add_option("--flip", dest="flip",
                          action="store_true", default=False,
                          help="Flip every other scan line.")


        output_group = optparse.OptionGroup(self.parser, "Output options")
        output_group.add_option("-o", "--out", dest="outfile",
                          help="Output prefix. [sinogram]", metavar="FILE", default="sinogram")
        output_group.add_option("--data-set", dest="output_set",
                          help="Location to save data set.", metavar="STRING", default=None)

        self.parser.add_option_group(input_group)
        self.parser.add_option_group(output_group)

    @utils.Script.timed
    def parse(self):
        super(Assembler, self).parse()

        #   Parse input and output files/datasets, peak shapes

        self.do_flip = self.options.flip

        if len(self.args) == 1 and os.path.exists(self.args[0]):
            self.input_data = files.ImageFile(self.args[0]).getImage(self.options.input_set)
            self.darkcurrent_profile = files.ImageFile(self.args[0]).getImage(xraylib.DARKCURRENT_DATA_SET)
            self.output_shape = self.input_data.shape[:-1]
        else:
            self.parser.error("Could not open input file")


        self.peak = {
                'fwhm'     : self.options.peak_fwhm,
                'position' : self.options.peak_position,
                'shape'    : self.options.peak_shape
        }

        self.peak = utils.strip_none_values(self.peak)
        self.peak = utils.convert(self.peak,float)

        # Get peak options from dat file exported by DAWN
        if self.options.peak_file:
            with open(self.options.peak_file, 'rb') as f:
                try:
                    (header,data) = f.readlines()
                    assert('#' in header)
                    header = header[1:].strip().lower().split('\t')
                    data = map(float,data.split('\t'))
                    self.peak.update(zip(header,data))
                except:
                    self.parser.error("Could not parse peak file %s" % (self.options.peak_file,))

        if not self.options.output_set:
            self.output_set = 'xraylib/sinogram_%s'  % (self.peak['position'],)
        else:
            self.output_set = self.options.output_set

        self.out_file = h5py.File(self.options.outfile+'.h5')
        self.out_group = self.out_file.require_group(os.path.dirname(self.output_set))
        self.output_data = self.out_group.require_dataset(
                           name=os.path.basename(self.output_set),
                           shape=tuple(self.output_shape),
                           #chunks=tuple(self.,   self.input_data.shape[-1]),
                           dtype="float32"
        )


    @utils.Script.timed
    def assemble(self):
        """ Do weighted least squares fitting of peak shape
        to linear background using data in interval of three FWHM. """
        r_min = int(np.round(self.peak['position'] - 1.5*self.peak['fwhm']))
        r_max = int(np.round(self.peak['position'] + 1.5*self.peak['fwhm']))
        r = np.arange(r_min,r_max)


        peak_fun = fit.get_peak_function(**self.peak)

        self.output_peaks = self.out_group.require_dataset(
                           name=os.path.basename(self.output_set)+'_peaks',
                           shape=tuple(self.output_shape) + (2,r.size,),
                           #chunks=tuple(self.,   self.input_data.shape[-1]),
                           dtype="float32"
        )

        A = np.array([np.ones(r.size), r, peak_fun(r)])
        if len(self.darkcurrent_profile.shape) > 1:
            darkcurrent = self.darkcurrent_profile[...,r_min:r_max]
            if darkcurrent.shape[0] != self.input_data.shape[-2]:
                self.parser.error("Darkcurrent frames does not match the number of data frames")
            nframes = darkcurrent.shape[0]
        else:
            darkcurrent = self.darkcurrent_profile[r_min:r_max]
            darkcurrent.shape = (1,) + darkcurrent.shape
            nframes = 1

        ''' Fit peaks for sinogram. Last dimension is assumed
            to be the radial profile '''
        # Use temporary numpy array for assembly since we need reverse ::-1
        # indexing for flipping, which is not available with h5py
        sinogram = np.zeros(self.output_data.shape)
        for key in itertools.product(*map(xrange,self.input_data.shape[:-1])):
            signal = self.input_data[key][r_min:r_max]
            # Use signal as squared error. dy ~ sqrt(y)
            w = 1.0 / (signal+darkcurrent[key[-1] % nframes])
            B = A * np.array([w,w,w])
            covC = np.linalg.inv(np.dot(B,A.T))
            c = np.dot(np.dot(covC, B), signal)
            self.output_data[key] = c[2]

            self.output_peaks[key+(0,)] = signal
            self.output_peaks[key+(1,)] = np.dot(A.T,c)

        if self.do_flip:
            i=0
            for key in itertools.product(*map(xrange,self.output_data.shape[:-1])):
                if i%2:
                    print key
                    row = self.output_data[key,:]
                    self.output_data[key] = row[::-1]
                i+=1
                #for i in xrange(0,self.output.data.shape[-1]/2):
                    
                    

    @utils.Script.timed
    def output(self):
        # Write HDF5 file suitable for browsing in DAWN
        self.output_data[:] = self.sinogram
        self.out_file.close()

        # Write (possibly multiframe) sinogram in EDF format for reconstruction
        files.ImageFile(self.options.outfile+'.edf').saveImage(self.sinogram)

if __name__ == '__main__':
    assmbl = Assembler()

    assmbl.parser_setup()
    assmbl.parse()
    assmbl.assemble()
    assmbl.output()
else:
    pass
    # Initialize assmbl with values from DAWN
    # assmbl = Assembler(position=.., fwhm = ..., shape="gaussian")
