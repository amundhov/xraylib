#!/usr/bin/env python

import numpy as np
import os, optparse

import xraylib
from xraylib import f2w, files, utils


try:
    import pyFAI
except ImportError:
    pyFAI = None

class Calibration(utils.Script):
    def __init__(self):
        super(Calibration, self).__init__()
        self.usage = 'Usage: %prog <options> CALIBRATION_IMAGE [DARK_CURRENT1,DARK_CURRENT2,...]'
        self.description = """
        XRD calibration routine based on ring shape.
        """

    def parser_setup(self):
        super(Calibration, self).parser_setup()

        file_group = optparse.OptionGroup(self.parser, "File options")
        file_group.add_option("-o", "--out", dest="outfile",
                      help="Filename where calibration image is saved", metavar="FILE")
        file_group.add_option("--data-set", dest="data_set",
                      help="Location to save data set.", metavar="STRING", default="/xraylib/calibration_image")
        file_group.add_option("-d", "--dark", dest="dark",
                      help="list of dark images to average and subtract", default=None)
        file_group.add_option("-p", "--poni", dest="poni_file",
                      help="File to save detector geometry", metavar="FILE", default="geometry.poni")

        detector_group = optparse.OptionGroup(self.parser, "Detector options")
        detector_group.add_option("-D", "--detector", dest="detector_name",
                      help="Detector name", default=None)
        detector_group.add_option("--distance", dest="detector_distance",
                      help="Detector distance from sample", metavar="<distance> [mm]",default=None)
        detector_group.add_option ('--tilt', dest="detector_tilt", nargs=2, action='append',
                      help="", metavar="<tilt1> <tilt2> [degrees]", default=None)
        detector_group.add_option ('--origin', dest="detector_origin", nargs=2, action='append',
                      help="Detector origin wrt sample, also known as PONI (Point of normal incidence)",
                      metavar="<poni1> <poni2> [mm]", default=None)

        calibration_group = optparse.OptionGroup(self.parser, "Calibration options")
        calibration_group.add_option("--threshold", dest="calibration_threshold",
                      help="Threshold value for use in calibration.", default=None)
        calibration_group.add_option("--calibration_range", dest="calibration_range",
                      metavar="min,max",
                      help="Radial distance to use for .", default=None)
        #TODO Add r_min r_max threshold

        self.parser.add_option_group(file_group)
        self.parser.add_option_group(detector_group)
        self.parser.add_option_group(calibration_group)

    def parse(self):
        super(Calibration, self).parse()

        if len(self.args) == 0:
            self.parser.print_help()
            self.parser.exit()

        # Set up self.detector
        DETECTOR_KWARGS = {
                'distance': self.options.detector_distance,
                'origin'  : self.options.detector_origin,
                'tilt'    : self.options.detector_tilt,
        }

        if self.options.detector_name is not None:
            DETECTOR_KWARGS = utils.strip_none_values(DETECTOR_KWARGS)
            self.detector = f2w.get_detector(self.options.detector_name, **DETECTOR_KWARGS)
        else:
            self.parser.error("self.detector missing")

        calibration_image = files.ImageFile(self.args[0]).getImage()

        if self.options.dark:
            # FIXME allow files to be arguments, not comma separated list
            self.print_verbose("---> Averaging dark images")
            dark_current = files.averageImages(self.options.dark.split(","))
            calibration_image = calibration_image - dark_current

        if self.options.outfile:
            self.print_verbose('---> Saving %s' % (self.options.outfile,))
            f = files.ImageFile(self.options.outfile)
            f.saveImage(calibration_image, self.options.data_set)

        self.calibrator = f2w.Calibrator(calibration_image, self.detector)

        CALIBRATION_KWARGS = {
                'threshold': self.options.calibration_threshold,
        }
        self.CALIBRATION_KWARGS = utils.strip_none_values(CALIBRATION_KWARGS)

    def calibrate(self):
        self.print_verbose("---> Calibrating")
        self.calibrator.calibrate(**self.CALIBRATION_KWARGS)
        self.print_verbose(self.calibrator)

        if pyFAI is None and self.options.poni_file:
            self.parser.error("pyFAI needed for PONI file")
        elif pyFAI is not None and self.options.poni_file:
            from pyFAI import geometry
            g = geometry.Geometry(dist=self.detector._distance/1000.0, # mm-> m
                                  poni1=self.detector._origin[0]/1000.0, # mm -> m
                                  poni2=self.detector._origin[1]/1000.0, # mm -> m
                                  rot1=self.detector._tilt[0]*np.pi/180.0,   # deg -> rad
                                  rot2=self.detector._tilt[1]*np.pi/180.0,   # deg -> rad
                                  pixel1=self.detector._pixelsize[0]/1000.0,  # mm -> m
                                  pixel2=self.detector._pixelsize[1]/1000.0)  # mm -> m
            self.print_verbose("---> Writing geometry to", self.options.poni_file)
            g.save(self.options.poni_file)

if __name__ == "__main__":
    cal = Calibration()
    cal.parser_setup()
    cal.parse()
    # TODO: while loop where integration limits and threshold can be adjusted
    cal.calibrate()

